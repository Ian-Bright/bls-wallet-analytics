// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt
} from "@graphprotocol/graph-ts";

export class BLSKeySetForWallet extends ethereum.Event {
  get params(): BLSKeySetForWallet__Params {
    return new BLSKeySetForWallet__Params(this);
  }
}

export class BLSKeySetForWallet__Params {
  _event: BLSKeySetForWallet;

  constructor(event: BLSKeySetForWallet) {
    this._event = event;
  }

  get newBLSKey(): Array<BigInt> {
    return this._event.parameters[0].value.toBigIntArray();
  }

  get wallet(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class PendingBLSKeySet extends ethereum.Event {
  get params(): PendingBLSKeySet__Params {
    return new PendingBLSKeySet__Params(this);
  }
}

export class PendingBLSKeySet__Params {
  _event: PendingBLSKeySet;

  constructor(event: PendingBLSKeySet) {
    this._event = event;
  }

  get previousHash(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }

  get newBLSKey(): Array<BigInt> {
    return this._event.parameters[1].value.toBigIntArray();
  }
}

export class WalletCreated extends ethereum.Event {
  get params(): WalletCreated__Params {
    return new WalletCreated__Params(this);
  }
}

export class WalletCreated__Params {
  _event: WalletCreated;

  constructor(event: WalletCreated) {
    this._event = event;
  }

  get wallet(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get publicKey(): Array<BigInt> {
    return this._event.parameters[1].value.toBigIntArray();
  }
}

export class WalletOperationProcessed extends ethereum.Event {
  get params(): WalletOperationProcessed__Params {
    return new WalletOperationProcessed__Params(this);
  }
}

export class WalletOperationProcessed__Params {
  _event: WalletOperationProcessed;

  constructor(event: WalletOperationProcessed) {
    this._event = event;
  }

  get wallet(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get nonce(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get actions(): Array<WalletOperationProcessedActionsStruct> {
    return this._event.parameters[2].value.toTupleArray<
      WalletOperationProcessedActionsStruct
    >();
  }

  get success(): boolean {
    return this._event.parameters[3].value.toBoolean();
  }

  get results(): Array<Bytes> {
    return this._event.parameters[4].value.toBytesArray();
  }
}

export class WalletOperationProcessedActionsStruct extends ethereum.Tuple {
  get ethValue(): BigInt {
    return this[0].toBigInt();
  }

  get contractAddress(): Address {
    return this[1].toAddress();
  }

  get encodedFunction(): Bytes {
    return this[2].toBytes();
  }
}

export class verificationGateway__measureOperationGasInputOpStruct extends ethereum.Tuple {
  get nonce(): BigInt {
    return this[0].toBigInt();
  }

  get gas(): BigInt {
    return this[1].toBigInt();
  }

  get actions(): Array<
    verificationGateway__measureOperationGasInputOpActionsStruct
  > {
    return this[2].toTupleArray<
      verificationGateway__measureOperationGasInputOpActionsStruct
    >();
  }
}

export class verificationGateway__measureOperationGasInputOpActionsStruct extends ethereum.Tuple {
  get ethValue(): BigInt {
    return this[0].toBigInt();
  }

  get contractAddress(): Address {
    return this[1].toAddress();
  }

  get encodedFunction(): Bytes {
    return this[2].toBytes();
  }
}

export class verificationGateway__processBundleResult {
  value0: Array<boolean>;
  value1: Array<Array<Bytes>>;

  constructor(value0: Array<boolean>, value1: Array<Array<Bytes>>) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromBooleanArray(this.value0));
    map.set("value1", ethereum.Value.fromBytesMatrix(this.value1));
    return map;
  }

  getSuccesses(): Array<boolean> {
    return this.value0;
  }

  getResults(): Array<Array<Bytes>> {
    return this.value1;
  }
}

export class verificationGateway__processBundleInputBundleStruct extends ethereum.Tuple {
  get signature(): Array<BigInt> {
    return this[0].toBigIntArray();
  }

  get senderPublicKeys(): Array<Array<BigInt>> {
    return this[1].toBigIntMatrix();
  }

  get operations(): Array<
    verificationGateway__processBundleInputBundleOperationsStruct
  > {
    return this[2].toTupleArray<
      verificationGateway__processBundleInputBundleOperationsStruct
    >();
  }
}

export class verificationGateway__processBundleInputBundleOperationsStruct extends ethereum.Tuple {
  get nonce(): BigInt {
    return this[0].toBigInt();
  }

  get gas(): BigInt {
    return this[1].toBigInt();
  }

  get actions(): Array<
    verificationGateway__processBundleInputBundleOperationsActionsStruct
  > {
    return this[2].toTupleArray<
      verificationGateway__processBundleInputBundleOperationsActionsStruct
    >();
  }
}

export class verificationGateway__processBundleInputBundleOperationsActionsStruct extends ethereum.Tuple {
  get ethValue(): BigInt {
    return this[0].toBigInt();
  }

  get contractAddress(): Address {
    return this[1].toAddress();
  }

  get encodedFunction(): Bytes {
    return this[2].toBytes();
  }
}

export class verificationGateway extends ethereum.SmartContract {
  static bind(address: Address): verificationGateway {
    return new verificationGateway("verificationGateway", address);
  }

  BLSPublicKeyFromHash(param0: Bytes, param1: BigInt): BigInt {
    let result = super.call(
      "BLSPublicKeyFromHash",
      "BLSPublicKeyFromHash(bytes32,uint256):(uint256)",
      [
        ethereum.Value.fromFixedBytes(param0),
        ethereum.Value.fromUnsignedBigInt(param1)
      ]
    );

    return result[0].toBigInt();
  }

  try_BLSPublicKeyFromHash(
    param0: Bytes,
    param1: BigInt
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "BLSPublicKeyFromHash",
      "BLSPublicKeyFromHash(bytes32,uint256):(uint256)",
      [
        ethereum.Value.fromFixedBytes(param0),
        ethereum.Value.fromUnsignedBigInt(param1)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  blsLib(): Address {
    let result = super.call("blsLib", "blsLib():(address)", []);

    return result[0].toAddress();
  }

  try_blsLib(): ethereum.CallResult<Address> {
    let result = super.tryCall("blsLib", "blsLib():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  blsWalletLogic(): Address {
    let result = super.call("blsWalletLogic", "blsWalletLogic():(address)", []);

    return result[0].toAddress();
  }

  try_blsWalletLogic(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "blsWalletLogic",
      "blsWalletLogic():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  hashFromWallet(param0: Address): Bytes {
    let result = super.call(
      "hashFromWallet",
      "hashFromWallet(address):(bytes32)",
      [ethereum.Value.fromAddress(param0)]
    );

    return result[0].toBytes();
  }

  try_hashFromWallet(param0: Address): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "hashFromWallet",
      "hashFromWallet(address):(bytes32)",
      [ethereum.Value.fromAddress(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  isValidSignature(hash: Bytes, signature: Bytes): boolean {
    let result = super.call(
      "isValidSignature",
      "isValidSignature(bytes32,bytes):(bool)",
      [ethereum.Value.fromFixedBytes(hash), ethereum.Value.fromBytes(signature)]
    );

    return result[0].toBoolean();
  }

  try_isValidSignature(
    hash: Bytes,
    signature: Bytes
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "isValidSignature",
      "isValidSignature(bytes32,bytes):(bool)",
      [ethereum.Value.fromFixedBytes(hash), ethereum.Value.fromBytes(signature)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  measureOperationGas(
    publicKey: Array<BigInt>,
    op: verificationGateway__measureOperationGasInputOpStruct
  ): BigInt {
    let result = super.call(
      "measureOperationGas",
      "measureOperationGas(uint256[4],(uint256,uint256,(uint256,address,bytes)[])):(uint256)",
      [
        ethereum.Value.fromUnsignedBigIntArray(publicKey),
        ethereum.Value.fromTuple(op)
      ]
    );

    return result[0].toBigInt();
  }

  try_measureOperationGas(
    publicKey: Array<BigInt>,
    op: verificationGateway__measureOperationGasInputOpStruct
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "measureOperationGas",
      "measureOperationGas(uint256[4],(uint256,uint256,(uint256,address,bytes)[])):(uint256)",
      [
        ethereum.Value.fromUnsignedBigIntArray(publicKey),
        ethereum.Value.fromTuple(op)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  pendingBLSPublicKeyFromHash(param0: Bytes, param1: BigInt): BigInt {
    let result = super.call(
      "pendingBLSPublicKeyFromHash",
      "pendingBLSPublicKeyFromHash(bytes32,uint256):(uint256)",
      [
        ethereum.Value.fromFixedBytes(param0),
        ethereum.Value.fromUnsignedBigInt(param1)
      ]
    );

    return result[0].toBigInt();
  }

  try_pendingBLSPublicKeyFromHash(
    param0: Bytes,
    param1: BigInt
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "pendingBLSPublicKeyFromHash",
      "pendingBLSPublicKeyFromHash(bytes32,uint256):(uint256)",
      [
        ethereum.Value.fromFixedBytes(param0),
        ethereum.Value.fromUnsignedBigInt(param1)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  pendingBLSPublicKeyTimeFromHash(param0: Bytes): BigInt {
    let result = super.call(
      "pendingBLSPublicKeyTimeFromHash",
      "pendingBLSPublicKeyTimeFromHash(bytes32):(uint256)",
      [ethereum.Value.fromFixedBytes(param0)]
    );

    return result[0].toBigInt();
  }

  try_pendingBLSPublicKeyTimeFromHash(
    param0: Bytes
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "pendingBLSPublicKeyTimeFromHash",
      "pendingBLSPublicKeyTimeFromHash(bytes32):(uint256)",
      [ethereum.Value.fromFixedBytes(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  pendingMessageSenderSignatureFromHash(param0: Bytes, param1: BigInt): BigInt {
    let result = super.call(
      "pendingMessageSenderSignatureFromHash",
      "pendingMessageSenderSignatureFromHash(bytes32,uint256):(uint256)",
      [
        ethereum.Value.fromFixedBytes(param0),
        ethereum.Value.fromUnsignedBigInt(param1)
      ]
    );

    return result[0].toBigInt();
  }

  try_pendingMessageSenderSignatureFromHash(
    param0: Bytes,
    param1: BigInt
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "pendingMessageSenderSignatureFromHash",
      "pendingMessageSenderSignatureFromHash(bytes32,uint256):(uint256)",
      [
        ethereum.Value.fromFixedBytes(param0),
        ethereum.Value.fromUnsignedBigInt(param1)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  processBundle(
    bundle: verificationGateway__processBundleInputBundleStruct
  ): verificationGateway__processBundleResult {
    let result = super.call(
      "processBundle",
      "processBundle((uint256[2],uint256[4][],(uint256,uint256,(uint256,address,bytes)[])[])):(bool[],bytes[][])",
      [ethereum.Value.fromTuple(bundle)]
    );

    return new verificationGateway__processBundleResult(
      result[0].toBooleanArray(),
      result[1].toBytesMatrix()
    );
  }

  try_processBundle(
    bundle: verificationGateway__processBundleInputBundleStruct
  ): ethereum.CallResult<verificationGateway__processBundleResult> {
    let result = super.tryCall(
      "processBundle",
      "processBundle((uint256[2],uint256[4][],(uint256,uint256,(uint256,address,bytes)[])[])):(bool[],bytes[][])",
      [ethereum.Value.fromTuple(bundle)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new verificationGateway__processBundleResult(
        value[0].toBooleanArray(),
        value[1].toBytesMatrix()
      )
    );
  }

  walletFromHash(param0: Bytes): Address {
    let result = super.call(
      "walletFromHash",
      "walletFromHash(bytes32):(address)",
      [ethereum.Value.fromFixedBytes(param0)]
    );

    return result[0].toAddress();
  }

  try_walletFromHash(param0: Bytes): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "walletFromHash",
      "walletFromHash(bytes32):(address)",
      [ethereum.Value.fromFixedBytes(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  walletProxyAdmin(): Address {
    let result = super.call(
      "walletProxyAdmin",
      "walletProxyAdmin():(address)",
      []
    );

    return result[0].toAddress();
  }

  try_walletProxyAdmin(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "walletProxyAdmin",
      "walletProxyAdmin():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }
}

export class ConstructorCall extends ethereum.Call {
  get inputs(): ConstructorCall__Inputs {
    return new ConstructorCall__Inputs(this);
  }

  get outputs(): ConstructorCall__Outputs {
    return new ConstructorCall__Outputs(this);
  }
}

export class ConstructorCall__Inputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }

  get bls(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class ConstructorCall__Outputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }
}

export class MeasureOperationGasCall extends ethereum.Call {
  get inputs(): MeasureOperationGasCall__Inputs {
    return new MeasureOperationGasCall__Inputs(this);
  }

  get outputs(): MeasureOperationGasCall__Outputs {
    return new MeasureOperationGasCall__Outputs(this);
  }
}

export class MeasureOperationGasCall__Inputs {
  _call: MeasureOperationGasCall;

  constructor(call: MeasureOperationGasCall) {
    this._call = call;
  }

  get publicKey(): Array<BigInt> {
    return this._call.inputValues[0].value.toBigIntArray();
  }

  get op(): MeasureOperationGasCallOpStruct {
    return changetype<MeasureOperationGasCallOpStruct>(
      this._call.inputValues[1].value.toTuple()
    );
  }
}

export class MeasureOperationGasCall__Outputs {
  _call: MeasureOperationGasCall;

  constructor(call: MeasureOperationGasCall) {
    this._call = call;
  }

  get value0(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class MeasureOperationGasCallOpStruct extends ethereum.Tuple {
  get nonce(): BigInt {
    return this[0].toBigInt();
  }

  get gas(): BigInt {
    return this[1].toBigInt();
  }

  get actions(): Array<MeasureOperationGasCallOpActionsStruct> {
    return this[2].toTupleArray<MeasureOperationGasCallOpActionsStruct>();
  }
}

export class MeasureOperationGasCallOpActionsStruct extends ethereum.Tuple {
  get ethValue(): BigInt {
    return this[0].toBigInt();
  }

  get contractAddress(): Address {
    return this[1].toAddress();
  }

  get encodedFunction(): Bytes {
    return this[2].toBytes();
  }
}

export class ProcessBundleCall extends ethereum.Call {
  get inputs(): ProcessBundleCall__Inputs {
    return new ProcessBundleCall__Inputs(this);
  }

  get outputs(): ProcessBundleCall__Outputs {
    return new ProcessBundleCall__Outputs(this);
  }
}

export class ProcessBundleCall__Inputs {
  _call: ProcessBundleCall;

  constructor(call: ProcessBundleCall) {
    this._call = call;
  }

  get bundle(): ProcessBundleCallBundleStruct {
    return changetype<ProcessBundleCallBundleStruct>(
      this._call.inputValues[0].value.toTuple()
    );
  }
}

export class ProcessBundleCall__Outputs {
  _call: ProcessBundleCall;

  constructor(call: ProcessBundleCall) {
    this._call = call;
  }

  get successes(): Array<boolean> {
    return this._call.outputValues[0].value.toBooleanArray();
  }

  get results(): Array<Array<Bytes>> {
    return this._call.outputValues[1].value.toBytesMatrix();
  }
}

export class ProcessBundleCallBundleStruct extends ethereum.Tuple {
  get signature(): Array<BigInt> {
    return this[0].toBigIntArray();
  }

  get senderPublicKeys(): Array<Array<BigInt>> {
    return this[1].toBigIntMatrix();
  }

  get operations(): Array<ProcessBundleCallBundleOperationsStruct> {
    return this[2].toTupleArray<ProcessBundleCallBundleOperationsStruct>();
  }
}

export class ProcessBundleCallBundleOperationsStruct extends ethereum.Tuple {
  get nonce(): BigInt {
    return this[0].toBigInt();
  }

  get gas(): BigInt {
    return this[1].toBigInt();
  }

  get actions(): Array<ProcessBundleCallBundleOperationsActionsStruct> {
    return this[2].toTupleArray<
      ProcessBundleCallBundleOperationsActionsStruct
    >();
  }
}

export class ProcessBundleCallBundleOperationsActionsStruct extends ethereum.Tuple {
  get ethValue(): BigInt {
    return this[0].toBigInt();
  }

  get contractAddress(): Address {
    return this[1].toAddress();
  }

  get encodedFunction(): Bytes {
    return this[2].toBytes();
  }
}

export class RecoverWalletCall extends ethereum.Call {
  get inputs(): RecoverWalletCall__Inputs {
    return new RecoverWalletCall__Inputs(this);
  }

  get outputs(): RecoverWalletCall__Outputs {
    return new RecoverWalletCall__Outputs(this);
  }
}

export class RecoverWalletCall__Inputs {
  _call: RecoverWalletCall;

  constructor(call: RecoverWalletCall) {
    this._call = call;
  }

  get walletAddressSignature(): Array<BigInt> {
    return this._call.inputValues[0].value.toBigIntArray();
  }

  get blsKeyHash(): Bytes {
    return this._call.inputValues[1].value.toBytes();
  }

  get salt(): Bytes {
    return this._call.inputValues[2].value.toBytes();
  }

  get newBLSKey(): Array<BigInt> {
    return this._call.inputValues[3].value.toBigIntArray();
  }

  get signatureExpiryTimestamp(): BigInt {
    return this._call.inputValues[4].value.toBigInt();
  }
}

export class RecoverWalletCall__Outputs {
  _call: RecoverWalletCall;

  constructor(call: RecoverWalletCall) {
    this._call = call;
  }
}

export class SetBLSKeyForWalletCall extends ethereum.Call {
  get inputs(): SetBLSKeyForWalletCall__Inputs {
    return new SetBLSKeyForWalletCall__Inputs(this);
  }

  get outputs(): SetBLSKeyForWalletCall__Outputs {
    return new SetBLSKeyForWalletCall__Outputs(this);
  }
}

export class SetBLSKeyForWalletCall__Inputs {
  _call: SetBLSKeyForWalletCall;

  constructor(call: SetBLSKeyForWalletCall) {
    this._call = call;
  }

  get messageSenderSignature(): Array<BigInt> {
    return this._call.inputValues[0].value.toBigIntArray();
  }

  get publicKey(): Array<BigInt> {
    return this._call.inputValues[1].value.toBigIntArray();
  }

  get signatureExpiryTimestamp(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }
}

export class SetBLSKeyForWalletCall__Outputs {
  _call: SetBLSKeyForWalletCall;

  constructor(call: SetBLSKeyForWalletCall) {
    this._call = call;
  }
}

export class SetPendingBLSKeyForWalletCall extends ethereum.Call {
  get inputs(): SetPendingBLSKeyForWalletCall__Inputs {
    return new SetPendingBLSKeyForWalletCall__Inputs(this);
  }

  get outputs(): SetPendingBLSKeyForWalletCall__Outputs {
    return new SetPendingBLSKeyForWalletCall__Outputs(this);
  }
}

export class SetPendingBLSKeyForWalletCall__Inputs {
  _call: SetPendingBLSKeyForWalletCall;

  constructor(call: SetPendingBLSKeyForWalletCall) {
    this._call = call;
  }

  get signatureExpiryTimestamp(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }
}

export class SetPendingBLSKeyForWalletCall__Outputs {
  _call: SetPendingBLSKeyForWalletCall;

  constructor(call: SetPendingBLSKeyForWalletCall) {
    this._call = call;
  }
}

export class SetTrustedBLSGatewayCall extends ethereum.Call {
  get inputs(): SetTrustedBLSGatewayCall__Inputs {
    return new SetTrustedBLSGatewayCall__Inputs(this);
  }

  get outputs(): SetTrustedBLSGatewayCall__Outputs {
    return new SetTrustedBLSGatewayCall__Outputs(this);
  }
}

export class SetTrustedBLSGatewayCall__Inputs {
  _call: SetTrustedBLSGatewayCall;

  constructor(call: SetTrustedBLSGatewayCall) {
    this._call = call;
  }

  get hash(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }

  get blsGateway(): Address {
    return this._call.inputValues[1].value.toAddress();
  }
}

export class SetTrustedBLSGatewayCall__Outputs {
  _call: SetTrustedBLSGatewayCall;

  constructor(call: SetTrustedBLSGatewayCall) {
    this._call = call;
  }
}

export class WalletAdminCallCall extends ethereum.Call {
  get inputs(): WalletAdminCallCall__Inputs {
    return new WalletAdminCallCall__Inputs(this);
  }

  get outputs(): WalletAdminCallCall__Outputs {
    return new WalletAdminCallCall__Outputs(this);
  }
}

export class WalletAdminCallCall__Inputs {
  _call: WalletAdminCallCall;

  constructor(call: WalletAdminCallCall) {
    this._call = call;
  }

  get hash(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }

  get encodedFunction(): Bytes {
    return this._call.inputValues[1].value.toBytes();
  }
}

export class WalletAdminCallCall__Outputs {
  _call: WalletAdminCallCall;

  constructor(call: WalletAdminCallCall) {
    this._call = call;
  }
}
